{"autoload/vimqq/queue.vim":{"token_count":530,"summary":"This file defines a basic queue data structure implemented within Vim using Vimscript. The `vimqq#queue#new()` function creates a new queue instance, which is a dictionary-like object with methods for enqueueing, dequeueing, peeking, getting the size, checking for emptiness, retrieving all items, and clearing the queue.  Each method ensures that items are not added to the queue twice, utilizing a set for efficient checking.","checksum":"be4a37956ebc4ca410cbb27b9acb5647c88f30904ebdad717109fa25bdb2b7bf"},"tests/mocks/mock_llama_cpp.py":{"token_count":1101,"summary":"This Python file implements a mock server for a language model, simulating the `/v1/chat/completions` endpoint. It provides basic functionality for tracking query counts (including warm-up and streaming queries), and handles both streaming and non-streaming responses.\n\nKey features include:\n\n*   **Flask Application:**  Uses Flask to create a web application with API endpoints.\n*   **API Endpoints:**\n    *   `/alive`: Returns a simple \"alive\" response to indicate the server is running.\n    *   `/reset`: Clears the `stats` dictionary.\n    *   `/stats`: Returns the current statistics.\n    *   `/tokenize`:  Receives a JSON payload with `content` and splits the content into tokens.\n    *   `/v1/chat/completions`: Simulates a chat completion endpoint, handling streaming and non-streaming requests.  It tracks query counts (warm-ups, stream queries, non-stream queries) and generates responses with placeholder content (\"BEGIN\", \"END\") for streaming.  For non-streaming requests, it returns a response with a length-based placeholder.\n*   **Signal Handling:**  Implements signal handlers for `SIGINT` and `SIGTERM` to gracefully exit the server.\n*   **Statistics Tracking:** Uses a `defaultdict(int)` to store and increment query counts.\n*   **Logging:** Configures logging to a file and also to the console, providing timestamps and log levels.\n*   **Argument Parsing:**  Uses `argparse` to handle command-line arguments for port and log directory.\n*   **Streaming Response:** Supports streaming responses using `text/event-stream` content type.  It simulates a stream by yielding chunks of the response data.\n","checksum":"e8640d483852c417d41ad10a9e1c32d6f3b120902aed843439d125428aba8374"},"autoload/vimqq/ttft.vim":{"token_count":227,"summary":"This file implements a time-to-first-token (TTFT) measurement system for VimQQ, specifically designed to track the latency of the first token received from a chat. It utilizes `reltime` to record timestamps of when a chat starts waiting and when the first token is received.  The `user_started_waiting` function records the timestamp when a chat begins waiting, and the `first_token` function calculates and logs the latency between the start waiting time and the first token arrival, handling cases where no start time is recorded. It also uses `vimqq#log#info` and `vimqq#log#warning` for logging purposes.","checksum":"bee79ad4bb0af2a544405d58d18718f1a2e7ac11de5f9898f8ee53565ae0b99e"},"tests/local/test_anthropic_api.vim":{"token_count":549,"summary":"This Themis suite, `test_anthropic_api.vim`, tests the Anthropic API's streaming text functionality using a mock server. It first checks for Python and the `flask` package. If not found, it skips the test with a message. Otherwise, it starts a mock server using `vimqq#platform#jobs#start` and registers a callback function `s:on_mock` to handle server jobs. The `test_stream_text` function sends a simple message to the mock server via the Anthropic API, enabling streaming. It collects the streamed chunks and asserts that the complete response matches an expected string.  A timeout is included to allow the mock server to respond.","checksum":"6e1e65bab02dd8786330e74e86318f506a6270b96c90f475c158cc346a20e55c"},"prompts/prompt_ui.txt":{"token_count":6,"summary":"Please provide the content of the source file within the `{vqq_message}` placeholder. I need the file's text to be able to summarize it and create high-level documentation.\n","checksum":"c0f4547d5b9eeacae523f04a6d2040a6dd5f7d99a500c09d41cff55ca2131a31"},"tests/local/test_tools_edit_file.vim":{"token_count":1371,"summary":"This Vim script file contains a test suite for the `vimqq#tools#edit_file` helper, which provides functionality for editing files within a Vim environment. The suite includes several test functions: `test_edit_file`, `test_edit_file_newline`, `test_edit_file_pattern_not_found`, `test_edit_file_more_instances`, `test_edit_file_not_found`, and `test_edit_file_async`. Each test function creates a temporary file, runs the `edit_file` tool with specific parameters (needle, replacement), and asserts that the actual output matches the expected output. The `test_edit_file_async` function specifically tests the asynchronous execution of the `edit_file` tool.  The `after_each` function ensures that temporary files are deleted after each test to maintain a clean testing environment. The tests cover scenarios such as successful file updates, newline replacements, pattern not found, multiple pattern instances, file not found, and asynchronous operation with result capture.","checksum":"bf3600499320b763908d5edc090b0e0b231ddbe0d596929676efdd0a0a53b078"},"autoload/vimqq/indexing/git.vim":{"token_count":688,"summary":"This VimQQ plugin provides functions for asynchronously retrieving files modified by Git within a project's repository. `vimqq#indexing#git#get_files` initiates a Git `ls-files` command to list cached and untracked files, and optionally processes them using a callback function. `vimqq#indexing#git#start` initiates a recursive indexing process, periodically checking for new Git modifications and processing the files found. It uses Vim's job system for asynchronous execution and includes logging for errors.","checksum":"94d0bae91428c6cb1e1319045c09d841b17225484d89e3764763f98d132a0cc9"},"tests/local/test_prompts.vim":{"token_count":525,"summary":"This file contains a suite of tests for the `vimqq#prompts#pick` function, which is used to display a prompt for selecting a source. The tests cover various scenarios including: selecting a source without context or index, selecting a source with context, selecting a source with index, selecting a source with both context and index, and selecting a source with a UI flag enabled. Each test reads the expected output from a specific text file and asserts that the actual output of `vimqq#prompts#pick` matches the expected output.","checksum":"02d89e2509fca45196860b9a2a5b657085d813d62f4e7c09ad6338924c9b19f7"},"autoload/vimqq/indexing/io.vim":{"token_count":569,"summary":"This file defines an indexing I/O module for VimQQ, responsible for managing the location of index files and providing functions to read and write index data. It defines a root directory for the index files, handles ignoring files specified in a `.vqqignore` file, and offers functions to locate the index directory, read index data from JSON files, and write index data to JSON files.  The functions `vimqq#indexing#io#root()`, `vimqq#indexing#io#ignores()`, `vimqq#indexing#io#read()`, and `vimqq#indexing#io#write()` implement this functionality.","checksum":"f17618f070b1da27b3abcd0f95f0bfdf92853f1703c14d1a4eba13a657987b75"},"LICENSE":{"token_count":231,"summary":"This file is a MIT License for the software, granting users the freedom to use, copy, modify, and distribute the software without restrictions, provided that the copyright notice and license terms are included in all copies. The software is provided \"as is\" without any warranties.","checksum":"e3165cb7891ffd61e7a44f6c1e72defa25e008c2ccd8926e76035fa12486a453"},"autoload/vimqq/indexing/basic.vim":{"token_count":1011,"summary":"This file defines a function `vimqq#indexing#basic#run()` that performs a basic indexing operation within the vimqq framework. It initializes queues and a root directory for the index, reads an existing index file (`basic.idx`), and then crawls a Git repository to count tokens and generate summaries for files.  The indexing process involves using queues to manage files, a checksum mechanism to avoid redundant processing, and logging for debugging.  It also includes a `vimqq#indexing#basic#format()` function to read and format the index data for display or other purposes. The function uses git to crawl the repository, and leverages a configuration of ignore patterns.","checksum":"227ec5448669a14df81e985943e1e1e50cc1317eab1759de05e3c209cd3e84d9"},"tests/local/tools_get_files.txt":{"token_count":4,"summary":"This file contains a simple greeting, \"Hello, world!\". It's a minimal example often used as an introductory program in many programming languages.","checksum":"d9014c4624844aa5bac314773d6b689ad467fa4e1d1a50a1b8a99d5a95f72ff5"},"autoload/vimqq/indexing/summary.vim":{"token_count":555,"summary":"This VimQQ indexing module implements a background summarization process for files within a Git repository. It utilizes a Llama.cpp indexer bot to generate summaries for each file queued for processing. The `start()` function initializes the summarization process, sets up a timer to periodically check for new files, and then iteratively reads, summarizes, and schedules the next file.  The module handles scheduling, error conditions (like non-existent files), and callbacks for when a summary is complete.","checksum":"2613ddac46b122e39f26eafbac4b8c98e0b4b53028c8a2adae32c74c56c7ae58"},"autoload/vimqq/bots/llama_cpp.vim":{"token_count":249,"summary":"This file defines a module for a Llama.cpp-based bot within Vim QQ. It initializes a global flag to prevent autoloading, sets default configuration options for the bot, and provides a function `vimqq#bots#llama_cpp#new` to create a new bot instance. This function copies and extends default configuration settings, sets the endpoint based on the provided address, and then creates a new bot using a Llama API implementation.","checksum":"c23f5d89cf6e4409b863b3ebaf027f061c0b574b783b3ec4ec2b6e107cf198de"},"autoload/vimqq/platform/path.vim":{"token_count":237,"summary":"This file defines two functions, `vimqq#platform#path#log` and `vimqq#platform#path#data`, that determine the platform-specific path to a data file (likely for VimQQ plugins).  `vimqq#platform#path#log` returns the path to the data file, using `stdpath(\"data\")` for Neovim and `~/.vim/` for other Vim versions. `vimqq#platform#path#data` calculates the path to the data file, ensuring that the necessary directory exists and creating it if it doesn't.  It also checks if the filename looks like a directory to avoid creating unnecessary directories.","checksum":"1bd5e96970be8ccf338289d7636fec98a4284396942e062bf099cd19e48e4616"},"tests/local/test_db.vim":{"token_count":1198,"summary":"This file contains a suite of tests for a `vimqq#db` database implementation, likely related to chat messaging. The tests cover various functionalities including database creation, chat management (creation, title setting, message appending, existence checking), persistence, ordering of chats, and chat deletion.  Each test function uses assertions from a helper function `s:assert` to verify expected behavior, ensuring data integrity and correct functionality of the database class. The tests demonstrate the creation and manipulation of databases and chats with associated messages, titles, and persistence checks.","checksum":"5460ac0c3382d7437e0a8dcabdd6490f984762944c2e8a08212429df71fa94af"},"prompts/prompt_context.txt":{"token_count":21,"summary":"Please provide the code snippet within the `{vqq_context}` and `{vqq_message}` tags. I need the actual code content to summarize it.\n","checksum":"8773d0c15e49cb55887e2ac97b7a22054728fdd6da1b70f00769548b785d19e0"},".github/workflows/vimqq-unittests.yml":{"token_count":222,"summary":"This GitHub Actions workflow automates the unit testing process for the `vimqq` project. It checks out the code, installs Vim and Python, installs project dependencies from `requirements.txt`, and then installs the `vim-themis` testing framework from a separate repository. Finally, it runs the unit tests using `themis` against the `tests/local` directory. The workflow is triggered on pushes and pull requests to the `main` branch.","checksum":"9529db1abb5cbf58ed12cd1a4621b8f06925c9e9ef149bb3848a5955469512c2"},"tests/mocks/mock_claude.py":{"token_count":954,"summary":"This Python file implements a Flask web application that simulates an API endpoint for streaming responses from a large language model (LLM), mimicking the behavior of Anthropic's Claude.  The `/v1/messages` endpoint accepts POST requests with a `stream` parameter indicating whether to return a streamed response or a complete JSON response.  When streaming is enabled, the application generates a series of SSE (Server-Sent Events) messages to represent the LLM's output, including `message_start`, `content_block_start`, `content_block_delta`, `content_block_stop`, `message_delta`, `ping`, and `message_stop` events.  The application uses a predefined response (`RESPONSES`) and simulates text streaming by splitting the response content into chunks and yielding them with delays to mimic network latency. The application also includes a message ID generation for the initial message start event and utilizes `argparse` to configure the port number.","checksum":"d1cfd1031de0000f2bacd78bbaa3c49dca150d4a5250ff94c521c61e3c631293"},"autoload/vimqq/platform/jobs.vim":{"token_count":934,"summary":"This file implements a job management system for Vim and Neovim, designed to handle asynchronous tasks initiated from within Vim/Neovim. It provides functions for starting jobs, managing active jobs to prevent excessive memory usage, and adapting to different callback mechanisms between Vim and Neovim. Specifically, `vimqq#platform#jobs#start` handles job initiation, utilizing Neovim's `jobstart` function when available and falling back to Vim's `job_start`. The `s:start_nvim` function transforms configuration options to be compatible with Neovim's job management system, handling stdout, stderr, and exit callbacks.  It also includes utility functions like `s:is_empty_list` for checking empty lists and `s:keep_job` for managing a limited number of active jobs to prevent memory leaks.  The system supports callbacks for job output, errors, and exit statuses.","checksum":"7b88216e6275710056a2edfc101902e99f7ba1246157e07512edb07237875fa9"},"prompts/prompt_index.txt":{"token_count":205,"summary":"This file implements a function to calculate the nth Fibonacci number using dynamic programming (memoization). It takes an integer `n` as input and returns the nth Fibonacci number. The function utilizes a memoization table (a dictionary) to store previously computed Fibonacci numbers, avoiding redundant calculations and significantly improving performance for larger values of `n`.  The function handles the base cases for n=0 and n=1 and recursively computes the Fibonacci number using the memoized values.  It also includes error handling to raise a ValueError if the input `n` is negative.","checksum":"dd1e0ab9c723beca139ec8eedc28a5919efe720ecd9c67ac2fd4afcaf629b8b5"},"autoload/vimqq/api/llama_cpp_adapter.vim":{"token_count":361,"summary":"This file defines a VimQQ API adapter for interacting with the llama.cpp model. Specifically, it handles the formatting of messages received from llama.cpp, particularly those containing tool calls. The `jinja` function iterates through a list of messages, extracts relevant information (like tool IDs and content), and adapts the messages for use within the VimQQ API. It includes error handling to catch potential issues during message adaptation and provides debugging logging. The code currently doesn't handle scenarios with multiple content entries within a single message.","checksum":"77fe40bbab85c69c7be9cb35d00fb3582773f61c6f469830268e212e4f120918"},"tests/local/test_log.vim":{"token_count":499,"summary":"This file tests the `themis` logging helper within the `vqq` testing framework. It defines a test suite (`test_log.vim`) that verifies the logging functionality, specifically ensuring that log messages are correctly associated with the file name and line number where they are generated. The tests cover various call sites, including a function defined within the suite, a method defined within the suite, a local function, and a closure.  Each test reads the log file, asserts that the log file contains exactly one line, and asserts that the line contains the correct file name and line number.","checksum":"294a93e4f2722d1dc2f6dfe45fce43036c9cd0ada62add4a26257e3fdca5c125"},"doc/indexing_results.txt":{"token_count":52,"summary":"This file logs the performance of two language models: Mistral-Small-24B-Instruct-2501 (a 24GiB quantized model) and gemma-3-4b-it (a 4GiB quantized model), including their runtimes in Q8_0 quantization. The Mistral model took 24 minutes and 25 seconds, while the gemma model's runtime is incomplete (indicated by \"??s\").","checksum":"d129c3897eeee4bbbe6797e2a4b6cf8ba64b9874ec93a0c3441bbdd0116d35c9"},"autoload/vimqq/bots/mock_bot.vim":{"token_count":122,"summary":"This file defines a function `vimqq#bots#mock_bot#new` which creates and returns a mock bot object for VimQQ bots. It initializes a mock API implementation and then creates a bot instance using that API and the provided configuration.  The function checks if the mock has already been loaded to prevent duplicate loading.","checksum":"5bd3f402c751619368b57485acbb84dadfa2f22819ccd887fe7ee71c9a6aa8fb"},"autoload/vimqq/util.vim":{"token_count":1586,"summary":"This file contains a collection of utility functions for the VimQQ plugin. These functions provide various helpers for logging, string manipulation, path matching, and data merging. Key functionalities include:\n\n*   **Plugin Root:** Defines a constant `s:ROOT` representing the plugin's directory, used for resolving relative paths.\n*   **Data Merging:** `vimqq#util#merge()` merges two dictionaries, summing values for common keys.\n*   **String Replacement:** `vimqq#util#replace()` performs a simple string replacement, avoiding magic replacements.\n*   **Logging Utilities:**  `vimqq#util#log_msg()` and `vimqq#util#log_chat()` provide debugging logging functionality, including inspecting message content and IDs.\n*   **Python Version Detection:** `vimqq#util#has_python()` attempts to determine the available Python interpreter (Python 3 or Python) and checks for the presence of the `flask` package.\n*   **Path Matching:** `vimqq#util#path_matches_patterns()` checks if a given file path matches any patterns in a list of patterns, similar to gitignore.  It supports basic wildcard matching, negation, and directory-only matching.","checksum":"7077e01e9bbab837d169e8d9ee921c894bd575dd64c7e2434e8e34a41225fd60"},".vqqignore":{"token_count":6,"summary":"This repository contains example usage and benchmark results for the codebase. The `examples` directory provides illustrative code snippets demonstrating various functionalities and how to integrate them into projects. The `benchmarks` directory houses performance tests and measurements, likely comparing the efficiency of different implementations or configurations.","checksum":"e2e4de39deed69b142df4d3c0fd1eca04455dd4a865f719262a8496af2400e72"},"autoload/vimqq/api/llama_cpp_builder.vim":{"token_count":918,"summary":"This file defines two functions, `vimqq#api#llama_cpp_builder#streaming` and `vimqq#api#llama_cpp_builder#plain`, within the `vimqq` module. Both functions create message builders for interacting with a Llama.cpp API, primarily used for assistant roles. The `streaming` function handles streaming responses from the API, appending text chunks as they arrive. The `plain` function constructs a complete message from a list of parts, suitable for situations where the entire response is available at once.  Both functions include functions for appending text, handling delta responses (partial updates), tracking token usage and timings, and signaling completion of the message. The `plain` function also supports tool calls within the Llama.cpp responses.","checksum":"6bdfc0b46cf3c56782cdd90ad56400f751ba7ff6b9f46f4cbda3c53be28e1ce0"},"autoload/vimqq/sys_msg.vim":{"token_count":314,"summary":"This file defines functions for logging system messages to the VimQQ client. It introduces a global variable `g:autoloaded_vimqq_sys_msg` to prevent multiple autoloading and uses `vimqq#main#notify` to send system messages to the appropriate chat context. The functions `vimqq#sys_msg#log`, `vimqq#sys_msg#info`, `vimqq#sys_msg#warning`, and `vimqq#sys_msg#error` provide a convenient way to log messages at different levels (info, warning, error) associated with specific chat IDs.","checksum":"bb2fe6452eb1674744d80f2aad613abf163462fff0f910b0e8f4fbaea410d8dc"},"autoload/vimqq/bots/claude.vim":{"token_count":122,"summary":"This file defines a function `vimqq#bots#claude#new` that creates and returns a new Claude bot instance for Vim QQ. It initializes an Anthropic API client and then creates a new bot object, passing the API client and any provided configuration options. The function also checks if the module has already been autoloaded and exits if it has.","checksum":"681b094fbe59a8a071b4d973a01278d7a328de99c4d418a0000e026ba87d6f11"},"tests/local/test_dir/b.txt":{"token_count":2,"summary":"This file contains placeholder content \"b content\". It likely serves as a minimal example or a starting point for a larger file, requiring further development or specific content to be added.\n","checksum":"980e8c902cc4989847be32ce9f8e9f8e2f8a3331c49bcfdef51d10f65eb9d7b9"},"autoload/vimqq/bots/bot.vim":{"token_count":1293,"summary":"This VimQQ bot module provides a framework for integrating AI models into the VimQQ chat interface. It manages configuration, warmup processes, and message handling, including title generation and chat responses.\n\nKey features include:\n\n*   **Configuration:**  A default configuration dictionary (`s:DEFAULT_CONF`) defines parameters such as title token limits, max tokens, model selection, and system prompts.\n*   **Bot Creation:** The `vimqq#bots#bot#new()` function creates new bot instances, copying and extending the default configuration. It also sets up callbacks for warmup completion, title generation, and chat responses.\n*   **Warmup:** The bot supports an optional warmup phase, sending a message to the model to initialize it.\n*   **Title Generation:**  A dedicated function (`send_gen_title`) generates titles based on user input, using a system prompt and a title generation prompt.\n*   **Chat Handling:** The `send_chat` function handles sending messages to the AI model, supporting streaming responses and handling various callbacks for progress and completion. It also allows for tool usage and thinking tokens.\n*   **Message Formatting:** The `_format` function prepares messages for the API based on the bot's configuration and role.","checksum":"b6778a461e96ec160d802ecd4bcf9be89b88c4ac7e5df33bcdd18b20ab158d4e"},"autoload/vimqq/tools/create_file.vim":{"token_count":711,"summary":"This file defines a Vim plugin tool named `vimqq#tools#create_file` that allows users to create new files with specified paths and content. The tool checks if the target file already exists and, if it does, does nothing. Otherwise, it creates the file and writes the provided content to it. It also provides functions for schema definition, asynchronous execution, and formatted call output for documentation purposes.","checksum":"f64191967a71f87ac14800bb4b1423ceebf369493481663ec5d5289ed6e28043"},"requirements.txt":{"token_count":55,"summary":"This file lists the Python package dependencies required for unit tests. Specifically, it details the dependencies for tests in the `tests/vimqq` and `tests/mocks` directories: Flask, requests, pytest, and Anthropic. These dependencies are only needed for testing purposes and not for the plugin's core functionality.","checksum":"b12cf3dda547c95526a3310aac9f6d82f84ee29e92027c1752b667d9fb6566ac"},"tests/local/test_indexer_git_files.vim":{"token_count":937,"summary":"This VimQQ suite tests the `get_git_files_direct` function, which retrieves a list of files from a Git repository within a temporary directory. The `before_each` function creates a test directory, initializes a Git repository, and populates it with some test files, including tracked and untracked files within subdirectories. The `after_each` function cleans up the temporary directory. The `test_get_git_files_direct` function uses asynchronous calls to `vimqq#indexing#git#get_files` to retrieve the list of Git files. It verifies that the asynchronous operation completes successfully, that the correct number of files are found (including both tracked and untracked files), and that the specific expected files (`file1.txt`, `file2.txt`, and `subdir/file3.txt`) are present in the returned list.  It uses assertions to confirm these results.","checksum":"76ca085eccf8c30cb953628569d7829d1b3fc0f3a8ca6556df71d15e02b7be90"},"autoload/vimqq/api/anthropic_api.vim":{"token_count":2429,"summary":"This Vim plugin provides an API wrapper for Anthropic's Claude model, designed for use within the Vim text editor. It handles API requests, rate limiting, and streaming responses.\n\n**Key Features:**\n\n*   **API Initialization:** The `vimqq#api#anthropic_api#new()` function initializes the API client, setting up base URL, API key, and internal tracking mechanisms for rate limits, request IDs, and usage.\n*   **Streaming Support:** The plugin supports streaming responses from Claude, allowing for real-time display of generated text.  It utilizes a builder pattern to handle the streaming process.\n*   **Rate Limiting:**  Implements a rate limiting mechanism to prevent exceeding Anthropic's API usage limits.  It pauses execution for a specified duration when a rate limit is reached.\n*   **Usage Tracking:**  Tracks the number of tokens used for both input and output, providing insights into API costs. It caches usage information for each request ID.\n*   **Error Handling:** Includes basic error handling, specifically catching rate limit errors and logging errors.\n*   **Configuration:**  Uses global variables (`g:`) to store configurable parameters like the API key and cache size.\n*   **Builder Pattern:** Uses a builder pattern to manage the construction of API requests and responses, improving code organization and maintainability.\n\n**Overall, this plugin offers a streamlined and feature-rich way to integrate Anthropic's Claude model into the Vim environment, with a focus on usability, rate limiting, and tracking API usage.**","checksum":"775f2f332f6eaec39781a8eea5fcbe0f53f2b9fa0400d1c79740914f5127ed2e"},"autoload/vimqq/api/llama_api.vim":{"token_count":1532,"summary":"This Vimscript file defines a module, `vimqq#api#llama_api`, for interacting with a Llama-based API, likely integrated with a Llama.cpp server.  It provides functions for submitting chat requests (`chat`) and tokenizing text (`tokenize`). The `chat` function handles both streaming and non-streaming requests, utilizing a builder pattern to manage the communication with the Llama.cpp server.  It supports optional Jinja templates for formatting prompts and includes error handling and logging mechanisms. The `tokenize` function performs tokenization of input text and can optionally trigger a callback upon completion. The module initializes an API instance with configuration options, including the API endpoint and whether to use Jinja templates. It also maintains a request ID counter and a list of builders to manage individual requests.","checksum":"0131156c1f192868eff223b356bc88c2e4b91e30718a69722ff51eb788b2d910"},"doc/vimqq.txt":{"token_count":399,"summary":"VimQQ is an AI plugin for Vim and NeoVim designed to improve local model evaluation through features like remote model support (Claude, Deepseek, llama.cpp), automated KV cache warmup, and dynamic warmup on typing. It also includes hierarchical project indexing and LLM agents. The plugin has undergone several updates since version 0.0.6, including Git blame context support, Groq API integration, and improved autowarming. Version 0.0.9 is currently very experimental.","checksum":"be7cda833fd85bde084fd940c33eef74cd551ed9fd90456a558a5c9c15789e55"},"autoload/vimqq/indexing/token_counter.vim":{"token_count":605,"summary":"This file defines a function `vimqq#indexing#token_counter#start` that initiates a token counting process for files within a Git repository using a remote llama.cpp indexer bot. The function initializes a counter object, establishes a connection to the bot, and then enters a loop that dequeues files, checks for existence and readability, reads the file content, sends a token counting request to the bot, and handles the response.  It uses a timer to schedule the next file processing after a specified period. The `on_token_count_complete` function is called upon receiving the token count from the bot, logging the result and scheduling the next iteration.  The function also includes logic to handle empty queues and non-existent files, logging appropriate messages.","checksum":"a8bc5ae9d1c54af61abd7ecd28070c38dda526e74466b7d477c54cabeb4c65c1"},"tests/mocks/test_mock_claude.py":{"token_count":615,"summary":"This file contains a unit test suite for a mock Claude server (`anthropic.Anthropic`). The test suite uses the `anthropic` library to interact with the mock server and verifies that it returns a consistent response to simple user prompts (\"Hello\" and \"get weather\").  The test class `TestMockServer` first sets up a local server using `anthropic.Anthropic` and a `threading.Thread` to ensure the server is running before sending requests.  It then asserts that the server's response to both prompts matches the expected response \"Hello! How can I help you today?\". Finally, the test class tears down the server thread.","checksum":"be1932b7461d2e7a5c62b4f030e73dec9775770343e567dc8ffb7871b425ff9a"},"autoload/vimqq/api/readme.txt":{"token_count":499,"summary":"This file outlines the design for an API layer that handles interactions with various large language model providers (like llama.cpp, Anthropic, and Deepseek) to provide a unified interface. The core approach involves a modular design with three components per API implementation: a main module for network interactions, a message builder module responsible for creating messages in a consistent internal format, and a message adapter module for transforming those messages into the specific format required by each API.  User and internal logic utilize the internal format, while the API layer handles the translation between these formats.  A single `chat(params)` function serves as the primary entry point, accepting parameters such as model name, messages (formatted as dictionaries with 'role' and 'content' keys), token limits, streaming options, and completion callbacks. The design addresses differences between providers by utilizing separate message builders and adapters, ensuring compatibility with varying API conventions and output formats, including streaming and tool calling.","checksum":"e9833b58bb094af3a24aa299ecc908e93842a7df102983739cb8f5fe2cb37908"},"tests/local/test_tools_create_file.vim":{"token_count":981,"summary":"This Vimscript file contains a test suite for a `vimqq#tools#create_file` function, which is designed to create files. The suite includes tests for:\n\n1.  **Basic file creation:** Creates a new file with specified content and verifies the file's content and success message.\n2.  **File already exists:** Checks that the function handles attempts to create an existing file by returning an error message and ensuring the original file content is preserved.\n3.  **Asynchronous file creation:** Tests the asynchronous version of the file creation function, verifying the correct success or error message is returned and the file content remains unchanged.\n4.  **Asynchronous file creation with existing file:** Tests the asynchronous version with the scenario where the file already exists, ensuring it returns an error.\n\nEach test function includes assertions to verify the expected behavior and cleanup steps (`after_each`) to remove the created test files.","checksum":"da16f8bc6da50c40d2ca079f57ee7046d6536314b4e95548740dfe283ea96da8"},"tests/local/test_anthropic_adapter.vim":{"token_count":1940,"summary":"This file contains a test suite for the `vimqq#api#anthropic_adapter` module, which likely provides an interface to interact with the Claude AI model. The tests cover several functionalities: adapting tool schemas from a base format to a Claude-compatible format, running the model with and without system messages and tools, and testing the `thinking_tokens` feature which allows for extended thinking with a token budget.  Specifically, the tests include:\n\n*   **`test_to_claude()`:** Verifies that the `tool_schema` function correctly transforms a tool definition into a Claude-compatible schema.\n*   **`test_adapt_tools()`:** Tests the `adapt_tools` function, which converts a list of tool definitions to Claude-compatible tool definitions. It tests both a single tool and multiple tools.\n*   **`test_adapt_multiple_tools()`:** Similar to `test_adapt_tools()`, but tests the adaptation of multiple tool definitions.\n*   **`test_run_with_system_message()`:** Checks that the `run` function correctly handles system messages when calling the AI model.\n*   **`test_run_with_tools()`:** Confirms that the `run` function correctly includes the adapted tool schema when tools are provided as input.\n*   **`test_run_with_thinking_tokens()`:** Tests the `thinking_tokens` functionality, ensuring that the appropriate system message is sent to the model and that the token budget is correctly configured. The test also captures and verifies the system message sent during extended thinking.","checksum":"324f7292b34b4a6b86cbd00a221dd422cbb201a5fe73e8eb5421d6d6caab4809"},"prompts/prompt_context_ui.txt":{"token_count":26,"summary":"This file contains placeholder strings `{vqq_context}` and `{vqq_message}`. It likely represents a section of code or data that needs to be replaced with actual context and message values before being used.","checksum":"bad0b3c0eb4ada10d2fb99417aaa130d8fed692877743c00e5ad4a1d078ca5f4"},"tests/local/test_tools_run_cmd.vim":{"token_count":504,"summary":"This file defines a Themisis suite of tests for the `vimqq#tools#run_cmd` helper. It contains three test functions: `test_echo`, `test_ls`, and `test_nonexistent_dir`. `test_echo` runs the command `echo \"hello, world\"` and asserts that the standard output is \"hello, world\", the standard error is empty, and the return code is 0. `test_ls` runs the command `ls test_dir` and asserts similar results. `test_nonexistent_dir` attempts to list a non-existent directory and asserts that the standard output is empty and the return code is greater than 0. All tests utilize asynchronous command execution with a 100ms sleep to allow the command to complete.","checksum":"d4309a54f74021f6ec9a03e1a3d2fed6532336d57d55df632d79938168419307"},"tests/local/test_queue.vim":{"token_count":665,"summary":"This file contains a suite of tests for a `vimqq#queue` implementation. The tests cover basic queue operations such as creating a new queue, checking emptiness, enqueueing and dequeuing items, verifying that enqueueing duplicate items is prevented, and retrieving all items and clearing the queue.  Specifically, the tests verify the correct size and contents of the queue after each operation, ensuring that the queue behaves as expected.","checksum":"798dbde4e56ab9d09b2bd2e263dcce8b5b9a37994522000e678449b23c2ada3e"},"autoload/vimqq/bots/llama_cpp_indexer.vim":{"token_count":449,"summary":"This file defines a VimQQ bot for indexing files using Llama.cpp. The bot initializes an API client and provides functions for counting tokens and summarizing files. The `vimqq#bots#llama_cpp_indexer#new` function creates a new bot instance, configuring the API endpoint and defining functions for token counting and file summarization. The summarization function constructs a prompt using a predefined template, incorporating the file content, and then utilizes the Llama.cpp API to generate a summary.  The bot currently supports summarizing a single file at a time and utilizes a fixed `s:MAX_TOKENS` value.","checksum":"dc7fd7eddfe8789f2026374a0f7d57efd24d61b03f039f8a0c226bc8d3d285a1"},"tests/local/test_http.vim":{"token_count":1030,"summary":"This Vim script defines a test suite for a LlamaCpp server using the `themis` and `vimqq` libraries. The suite tests HTTP GET requests to the server, specifically checking for the 'alive' response, a 404 error, and a non-existent address.  It initializes a Python server mock using a `mock_llama_cpp.py` script, runs the server in the background, and then sends HTTP requests to the server. The `OnMock` function handles server job management.  The `test_http_get`, `test_http_get_404`, `test_http_get_na`, and `test_http_get_na_body` functions perform the actual HTTP requests and assertions using the `assert` helper. A check for Python availability is implemented, skipping the tests if Python or the Flask package is not found.  The `s:skip_all` variable controls whether tests are skipped due to missing dependencies.","checksum":"9bb75dcbead229a62749e9a08ad8c3a8c21b93c0388c4bca91ef3d17600fc796"},"autoload/vimqq/lucas.vim":{"token_count":432,"summary":"This Vim script defines a function `vimqq#lucas#load()` that loads and returns the contents of a `lucas.idx` file, which is used to track files and directories within a project. It first checks if the script has already been loaded. If not, it marks it as loaded.  The script then defines two helper functions: `s:load_index_lines()` which recursively searches for a `lucas.idx` file in the current directory and its parent directories, returning its contents; and `s:prepare_index_lines()` which parses the `lucas.idx` file (assumed to be in JSON format) and prepares the data into a newline-separated string suitable for output.  Finally, the main function calls `s:prepare_index_lines()` and returns the resulting string, or logs an error and returns `v:null` if the index file cannot be found.","checksum":"4858e5cf47d4b5de7012ae053df2b269ea684fc79b31ab3e7666633118dc139e"},".gitignore":{"token_count":18,"summary":"This file contains a list of hidden files and directories typically associated with a Python development environment. Specifically, it includes:\n\n*   `*.swp`: Vim swap files.\n*   `.ll_index`:  Launchy Library Index files.\n*   `__pycache__/**`:  Python bytecode cache directories.  These are automatically generated and should be ignored by version control systems.\n","checksum":"c88017d3aca0a412a83e3984bbf88af5119cede021af6fe0bdc1aebb20d2b5f9"},"autoload/vimqq/bots/claude_reviewer.vim":{"token_count":249,"summary":"This file defines a module for a Claude-based reviewer bot within VimQQ. It initializes a global flag to prevent autoloading multiple times and then defines a function `vimqq#bots#claude_reviewer#new()` to create and return a new bot instance. The bot uses an Anthropic API implementation and takes configuration options. It includes a helper function `_format()` to format messages into a structured format suitable for Claude, and a prompt function `vimqq#prompts#reviewer_prompt()` to define the system prompt.","checksum":"ef460770a1c914583fecde6cde494922c0423dd5279bb71386e921856d43423d"},"autoload/vimqq/ui.vim":{"token_count":2335,"summary":"This Vim plugin, `vimqq`, provides a user interface for interacting with a chat bot. It manages two buffers: one for the chat list and another for the chat conversation.  The plugin handles opening and managing these buffers, displaying chat history, appending new messages, and updating a queue size indicator. Key features include:\n\n*   **Buffer Management:** Automatically creates and manages the chat list and chat buffers, ensuring they are in the correct split window arrangement.\n*   **Message Display:**  Formats and appends messages to the chat buffer, including timestamps and author information.\n*   **Queue Display:** Shows the size of a queue associated with the bot.\n*   **History Display:** Displays a list of chat conversations and allows selection of a conversation to view its details.\n*   **Partial Message Handling:**  Supports displaying partial messages as they arrive.\n*   **Syntax Highlighting:**  Includes syntax highlighting for various message components, such as timestamps, author names, and bot messages.\n*   **Configuration:**  Allows customization of the chat window width and time format.\n*   **Keybindings:** Uses keybindings to navigate and interact with the chat list (select, quit, delete).","checksum":"4fa2a5b486cd6931b0d8ff37e2ecedd60a9f2fcf0ee5b8768bb499b414db1e14"},"autoload/vimqq/controller.vim":{"token_count":3367,"summary":"This Vim script file implements a controller for the Vimqq plugin, managing communication with a chatbot and handling user interactions. It initializes various components like the UI, database, bots, state, and toolset. The core functionality revolves around the `run_query` function, which handles sending messages to the chatbot, tracking in-flight requests, and managing the conversation flow.  It also includes functions for warmup, displaying chat history, showing individual chats, and handling user events like replies and tool executions.  The `send_message` function is the primary entry point for user input, orchestrating the message sending process and managing state.  The code utilizes a queue-based approach to handle multiple concurrent queries and incorporates logging and debugging features.  It also includes mechanisms for handling tool execution and managing chat titles, with a focus on benchmarking and testing scenarios.  The `fzf` function provides a fuzzy finder for selecting chats.","checksum":"5da28654c027f52e8cd222077da40fd4c4a9cd3224af475c5c40665572f03289"},"autoload/vimqq/main.vim":{"token_count":1211,"summary":"This Vim plugin, `vimqq`, provides a command-line interface for interacting with the Vimqq service. It manages a single instance of a controller, facilitating sending messages, displaying lists and chats, and handling various command variations (e.g., `qq` for regular messages, `qqn` for new chats, `qqi` with index, `qqt` with tools). The plugin utilizes a controller class to encapsulate the core logic of communicating with the Vimqq service. Key functions include `setup`, `notify`, `send_message`, `send_warmup`, `show_list`, `show_chat`, and command dispatch functions (`dispatch_new`, `dispatch`, `dispatch_index`, `dispatch_tools`) that handle different message types and arguments.  The plugin also includes a `fzf` function, likely for fuzzy finding, and handles command dispatch based on the count argument, allowing for both single and multi-line command execution.","checksum":"dfcf10b83b1ebf112e534418cf0977865c29572bea8da2cb3b0da550bdd70045"},"autoload/vimqq/db.vim":{"token_count":2801,"summary":"This Vimscript file implements a chat database module for Vimqq, designed to store and manage chat conversations as individual JSON files. It handles loading, saving, and managing chat data, including sequence IDs, metadata, and chat titles.  The module supports both legacy and new database formats.\n\nHere's a breakdown of the key functionalities:\n\n*   **Initialization (`vimqq#db#new`)**: Creates a new chat database instance, determining the chat directory based on the provided file path (either a JSON file or a directory). It ensures the chat directory exists, loads metadata from a `metadata.json` file (if present), and then loads chat data from individual `.json` files within the directory. It also handles migration from a legacy single-file format. It initializes a sequence ID counter and persists it to the metadata file.\n*   **Directory Management (`s:ensure_dir_exists`)**:  Creates a directory if it doesn't already exist.\n*   **Chat File Path (`s:chat_file`)**: Constructs the full path to a chat file based on the chat directory and chat ID.\n*   **Sequence ID Management (`s:max_seq_id`)**: Determines the highest sequence ID within a chat.\n*   **Database Functions**: Provides a set of functions for managing chats, including:\n    *   `db.seq_id()`: Increments and saves the sequence ID.\n    *   `db.set_tools()`:  Allows setting allowed tools for a chat.\n    *   `db.get_tools()`:  Retrieves the list of allowed tools.\n    *   `db.delete_chat()`:  Deletes a chat.\n    *   `db.has_title()`: Checks if a chat has a title.\n    *   `db.get_title()`: Retrieves the chat title.\n    *   `db.set_title()`: Sets a chat title.\n    *   `db.chat_exists()`: Checks if a chat exists.\n    *   `db.get_first_message()`: Retrieves the first message in a chat.\n    *   `db.append_message()`: Adds a message to a chat, updating the sequence ID if necessary.\n    *   `db.get_last_bot()`:  Retrieves the last bot message in a chat.\n    *   `db.get_ordered_chats()`: Returns an array of ordered chat objects.\n    *   `db.get_messages()`: Returns the list of messages in a chat.\n    *   `db.chat_len()`: Returns the number of bot messages in a chat.\n    *   `db.get_partial()`: Retrieves the partial message.\n    *   `db.clear_partial()`: Clears the partial message.\n    *   `db.new_chat()`: Creates a new chat and saves it to a JSON file.\n\nThe module utilizes JSON for storing chat data and metadata, providing a structured and persistent way to manage chat conversations.  It incorporates error handling and migration support to accommodate different database formats.","checksum":"eed3a687a2adb85185995bc50bd82b837b9dabb4205c227ffa46d0143d96ec5f"},"tests/local/test_fmt.vim":{"token_count":370,"summary":"This file defines three tests within a `themis` suite using `vimqq` for prompt formatting. The tests verify the correct formatting of prompts with context and escaped characters, and also the case where only the message is provided. Specifically, `test_content_with_prompt` checks the formatting of a prompt containing context and message, `test_content_escape` verifies escaping within the prompt, and `test_content_no_context` confirms correct formatting when no context is supplied.  Each test uses `themis#helper('assert')` to compare the formatted output with an expected string.","checksum":"777bd0b97b3153e0448c46c2a35add18a64c80f663529bae2f5bb72e04c25879"},"README.md":{"token_count":196,"summary":"Vim-qq is an experimental AI plugin for Vim/NeoVim that focuses on minimizing latency through local evaluation and aggressive caching. It supports both remote AI models (via APIs) and local models (using llama.cpp), offers automated KV cache warmup, dynamic warmup during typing, hierarchical project indexing, and AI agents with various roles, aiming for end-to-end feature implementation.","checksum":"3203b624dc37b87e3f8ad78a862a5f4c8b364d69eb14a30f30b27ffe3b72b67d"},"tests/local/test_tokenize.vim":{"token_count":685,"summary":"This Vim file uses the `themis` testing framework to test the `vqq_llama_cpp` API. It defines a test suite (`test_tokenize`) and a separate test (`test_token_count`). The tests involve starting a mock Llama CPP server using `vimqq#platform#jobs#start`, sending a tokenization request, and asserting the result. The `test_token_count` test utilizes a Llama CPP indexer bot to count tokens in a given string and verifies the count. The file includes logic to handle cases where Python or the Flask package are not installed, skipping the tests accordingly.  It also uses helper functions from `themis` and `vimqq` for assertion, job management, and API interaction.","checksum":"b8f7d306d8fa8606ec22a44915407c96770f8435312637c10eb15100f369fbdd"},"autoload/vimqq/api/mock_api.vim":{"token_count":1247,"summary":"This Vim plugin provides a mock API for the Vimqq API, primarily focused on simulating streaming responses.  It uses a builder pattern to manage different API calls and response types. The `vimqq#api#mock_api#new(conf)` function creates a new mock API instance. It supports both streaming and non-streaming responses, simulating the behavior of a real API. The `chat` function handles incoming chat messages and generates simulated responses.  The core logic involves using `vimqq#platform#jobs#start` to simulate asynchronous operations and callbacks (`on_stream_out`, `on_stream_close`, `on_out`, `on_close`, `on_error`) to mimic the flow of data during streaming and non-streaming scenarios.  The mock API doesn't actually perform any endpoint requests; it focuses solely on generating simulated responses based on input parameters.  It uses a simple counter (`_req_id`) to track requests and manage builders.  The `_on_stream_out` function handles the streaming of chunks of data, simulating a delayed response.  The `_on_stream_close` function is called when the stream is closed.  The `_on_out` function handles the sending of a complete, non-streaming response. The `_on_close` function handles closing the request.  The `_on_error` function handles errors. The `chat` function calculates conversation length to simulate a response.  It uses different builders (`vimqq#api#llama_cpp_builder#streaming` and `vimqq#api#llama_cpp_builder#plain`) based on whether streaming is enabled.","checksum":"4d545189e86adf568b6390dad6c1b2a05e4907b7a941fb87e54fb76522b878bf"},"autoload/vimqq/log.vim":{"token_count":1340,"summary":"This Vimscript file implements a logging system for the VimQQ plugin. It provides functions for logging messages at different levels (DEBUG, INFO, WARNING, ERROR) with optional file and format configuration. The logging functions utilize a custom `log_impl` function to handle formatting and writing to a log file.  It includes a function to parse the call stack to include file and line number information in log messages, and functions to handle logging at different levels.  The system also includes a `file()` function that returns the configured log file path. It includes TODO comments regarding file/line tracking issues with lambdas and script execution.","checksum":"6560847efa1e62da3b781c1d824cb944f308dd867e875caa559416256fe87261"},"tests/mocks/sample_mock_claude.py":{"token_count":124,"summary":"This code snippet demonstrates how to interact with the Anthropic API using the `anthropic` Python library. It initializes an `Anthropic` client, setting the base URL to `http://127.0.0.1:5000`. It then sends a simple \"Hello\" message to the Claude-3-5-sonnet-20241022 model using the `messages.stream` method, streaming the response text back to the console. The `max_tokens` parameter limits the response length to 1024 tokens, and the code iterates through the streamed text, printing each chunk to the console with a flush to ensure immediate output.\n","checksum":"30757ae83d9fe0d029fee4738c4e5102b19ecfeb3d41e5a93cf698fcff7e077a"},"tests/local/test_path_matches_patterns.vim":{"token_count":469,"summary":"This test suite, `test_path_matches_patterns`, verifies the functionality of the `vimqq#util#path_matches_patterns` function. It tests various scenarios including: empty patterns lists, exact filename matches, wildcard matching (*), directory matching, negated patterns (!), and patterns containing comments and whitespace. The tests confirm that the function correctly identifies whether a file path matches a given set of patterns.","checksum":"7796cb886de1a07c5dba0373ac830b3e34f1801df995227d59eaf49fda10d13b"},"prompts/prompt.txt":{"token_count":6,"summary":"Please provide the content of the source file so I can summarize it for you. I need the `{vqq_message}` content to be able to fulfill your request.\n","checksum":"c0f4547d5b9eeacae523f04a6d2040a6dd5f7d99a500c09d41cff55ca2131a31"},"autoload/vimqq/tools/edit_file.vim":{"token_count":1044,"summary":"This Vimscript file defines a tool named `vimqq#tools#edit_file` designed to replace a single string (needle) with another string (replacement) within a specified file. The tool takes a filepath, a needle string, and a replacement string as input. It first checks if the tool has already been loaded. If not, it sets a flag to indicate that it has been loaded.\n\nThe core functionality resides in the `run` function, which reads the file, counts the occurrences of the needle, and if a single instance is found, replaces it with the replacement string and writes the modified content back to the file.  Error handling is included for cases where the file is not found or multiple instances of the needle are present.  The `run_async` function allows for asynchronous execution of the tool, providing a callback function to handle the result. The `format_call` function generates a formatted string representation of a tool call for documentation purposes, including the filepath, needle, and replacement.  The `schema` function defines the tool's schema for use with documentation generators.","checksum":"db648f370cd06b10740312131340553a71a1a5add336d7e6d76495604250d8a9"},"tests/local/test_tools_get_files.vim":{"token_count":772,"summary":"This file contains a suite of tests for the `themis#tools#get_files` helper function using the `themis` and `vimqq` libraries. The tests cover the following scenarios:\n\n1.  **`test_get_files()`**:  Tests the function's ability to retrieve file contents successfully, verifying that it returns the expected content from a valid file (`tools_get_files.txt`) and includes the expected string \"Hello, world!\".\n\n2.  **`test_get_files_not_found()`**: Tests the function's behavior when a specified file does not exist, checking that it returns the expected error message \"ERROR: File not found.\" alongside the non-existent filename.\n\n3.  **`test_get_files_async()`**: Tests the asynchronous version of the `get_files` function. It verifies that the callback function is called correctly with the expected result when the file exists and contains valid content.\n\n4.  **`test_get_files_async_not_found()`**: Tests the asynchronous version of the function with a non-existent file, ensuring that the callback function is called correctly and returns the expected error message.","checksum":"0509854eac82e1e8a14ccfe8f179f3b9412d7409892c19448c6e5d830a59a7c7"},"tests/local/test_queries.vim":{"token_count":2637,"summary":"This Vim script file implements a test suite for a llama.cpp mock server using the `themis` framework and the `vimqq` plugin. It sets up a mock server using Python and Flask, manages chat interactions, and asserts the server's responses against expected values.\n\nThe suite includes tests for:\n\n*   `test_list_one`: Tests a single query with a simple response.\n*   `test_new_chat`: Tests creating a new chat and receiving a response.\n*   `test_new_chat_nodelay`: Tests creating a new chat and receiving a response without a delay, allowing for potentially out-of-order responses.\n*   `test_query`: Tests sending a single query to the mock server.\n*   `test_query_twice`: Tests sending two queries sequentially.\n*   `test_queue`: Tests sending multiple queries in a queue.\n*   `test_selection`: Tests selecting a range of lines and sending a query based on the selection.\n\nThe script uses functions like `s:normtime` to normalize timestamps, `s:server_stats` to retrieve server statistics, and `s:assert.equals` and `s:assert.includes` for assertions. It handles potential Python dependency issues and cleans up temporary files after each test.  It also uses `vimqq#util#has_python()` to check for Python's presence before attempting to run the mock server. The `s:skip_all` variable is used to skip tests if Python is not available.","checksum":"076777fdc5ea2801eb6c8f37fc1ec934354921d2888b24556bc42f57fc6faf6c"},"autoload/vimqq/prompts.vim":{"token_count":826,"summary":"This file defines a module `vimqq#prompts` containing functions for generating prompts used by the Vimqq bot. It handles title generation, file indexing prompts, reviewer prompts, and general prompt retrieval. Specifically, it reads prompts from text files located in a `prompts` directory relative to the bot's root directory. The `pick_title` function dynamically selects a prompt file based on whether context or index information is available in the message. The `apply` function substitutes placeholders within prompts using context and index data from the message.  It also includes a check to prevent sending index information to the title generation function.","checksum":"d233eaaffcbef9de56bc2e0f4852c081087273fc2c6c5f1795b259122775c70b"},"autoload/vimqq/tools/get_files.vim":{"token_count":637,"summary":"This VimQQ plugin function `vimqq#tools#get_files#new()` creates a tool that retrieves the content of one or more files specified by their paths. The tool accepts an `filepaths` argument, which is an array of file paths.  It iterates through each file path, checks if the file exists and is readable. If a file is found and readable, its content is added to the result array, along with the file path. If a file is not found, an error message is added to the result. The function returns a string containing the content of all files, separated by newlines. It also provides functions to format the tool call for documentation and to run the tool asynchronously with a callback function.  A configurable limit (`s:TOOL_FOLD_LIMIT`) is used to truncate long lists of filepaths in the formatted output.","checksum":"8d856fe693c2c5fba1a34c929071f717fdca740662ec2f5bd7c319f6a9773449"},"autoload/vimqq/platform/http.vim":{"token_count":485,"summary":"This file defines two functions, `vimqq#platform#http#post` and `vimqq#platform#http#get`, for sending HTTP requests from Vim using the `curl` command. `vimqq#platform#http#post` sends a POST request to a specified URL with optional headers and a JSON body, using a temporary file to store the headers. `vimqq#platform#http#get` sends a GET request to a specified URL with optional curl options, and it leverages the `vimqq#platform#jobs#start` function to handle the request and its response in a separate job. Both functions accept a `job_conf` argument for configuring response handling.","checksum":"6218f9b5413357e7888823bca474e8f8092a49190a88c0548ab99e20e06285fe"},"autoload/vimqq/state.vim":{"token_count":309,"summary":"This file defines a `vimqq#state` function that creates and manages the state for a VimQQ plugin. It initializes a dictionary-like object (`state`) that stores the current chat ID and provides functions for retrieving, setting, and creating chat IDs. The `_get_or_create_chat_id` function ensures a unique chat ID is assigned when a new chat is needed, and the `pick_chat_id` function allows for either using the existing chat ID or creating a new one. The state also stores a reference to the underlying database (`_db`).","checksum":"61b69c2683d275b51cb2c822b79fb5762ee21334e6c13c4c4a1790962d0cc49c"},"local_deploy.sh":{"token_count":176,"summary":"This bash script copies Vim configuration files (`.vim` and `.txt`) from a source directory to a destination directory within the user's Vim plugins directory.  It creates the destination directory if it doesn't exist and uses `find` to locate the files. For each file, it calculates the relative path, creates the corresponding directory structure in the destination, and then copies the file to its new location, preserving the original directory structure.  The script targets files in the current directory (`.`) and copies them to `~/.vim/pack/plugins/start/vimqq/`.","checksum":"e332f156a61740a344749ef2aac826a34b8a47b642b447018a3868dd4c0bff78"},"autoload/vimqq/platform/checksum.vim":{"token_count":100,"summary":"This file defines a VimQQ plugin function `vimqq#platform#checksum#sha256` that calculates the SHA256 checksum of the content of a given file. It first checks if the module has already been autoloaded and exits if it has. Otherwise, it sets a flag to indicate that the module has been autoloaded and then defines the function which reads the file content, joins the lines, and returns the SHA256 hash of the concatenated content.","checksum":"bc3891286677bc953289bc077d9f94a9515f5dbb696920b874995864221d05f3"},"prompts/prompt_index_ui.txt":{"token_count":37,"summary":"This file contains a Lucas index and its associated index size. The `vqq_lucas_index` variable holds the Lucas index data, and `vqq_lucas_index_size` specifies the size of that data in bytes. It likely represents a lookup table or data structure used for efficient access to Lucas indices within a larger system.","checksum":"1704868e3837ac380c1178d208a7c402a111e232908fc811a4cbc47fd8c8160d"},"tests/local/test_warmup.vim":{"token_count":651,"summary":"This file defines a Themison suite for testing the warmup functionality of a VQQ Llama CPP server. It uses a mock Llama CPP server running on port 8888 to collect server statistics. The `before` function starts the server, and the `after` function stops it. The `before_each` function resets the environment, including clearing chat directories and setting up the server. The `test_warmup` function sends a simple chat message, waits for 2 seconds, retrieves server statistics, and asserts that the retrieved statistics match an expected dictionary containing the number of chat queries and warmups. The suite skips if Python or the Flask package are not available.","checksum":"68faca0c4ac84b4e4f5205ef6ce63425d249198a6eac9058fc76b15076ab721a"},"doc/style.txt":{"token_count":61,"summary":"This file outlines coding conventions for Python projects, emphasizing readability and maintainability. It recommends using `snake_case` for function names, clearly distinguishes between private and public functions (private functions start with `s`, and private dictionary functions/methods start with `_`), advises against using `l:` in variable names, and specifies that constants should be named in `CAPITAL_CASE`. Finally, it stresses the importance of avoiding mutable script-level variables outside of the controller.","checksum":"206a70d7a791e4631ef5a0a4bea9b554fc331b1c1e6eef0676e1c0133776806e"},"plugin/vimqq.vim":{"token_count":257,"summary":"This file defines a series of Vim commands using the `command!` function to integrate with the vimqq plugin. It provides commands for dispatching various vimqq functions with different arguments, displaying lists, using FZF, and initializing the vimqq plugin.  It also includes a debugging command for opening a log file and conditionally initializes the plugin based on the `vqq_skip_init` global variable.","checksum":"86c8e21270f9a79605499983d216e5e32b2036e8a4b713d5bcf8533dbd6ba7c5"},"autoload/vimqq/tools/run_cmd.vim":{"token_count":898,"summary":"This Vimscript file defines a module named `vimqq#tools#run_cmd` that provides a function `run_cmd` for executing shell commands. The `run_cmd` function takes a command string as input, captures its standard output, standard error, and return code, and returns these values in a dictionary.  It uses temporary files to store the output and return code, ensuring proper cleanup. The module also includes functions for defining its schema (for documentation purposes), formatting a call to the `run_cmd` function, and running the command asynchronously using Vim's job system. The asynchronous execution utilizes a callback function to handle the results and ensures the original working directory is restored after command completion.  It handles cases where `mkdir` is available or not, utilizing `/tmp` as a fallback for temporary directory creation.","checksum":"53e5752f30aad6f6680d988ddb1dcf9cc785d6cf983503ccc924be5e8f8fd9bb"},"prompts/prompt_context_index.txt":{"token_count":246,"summary":"This file implements a function to calculate the factorial of a non-negative integer using recursion. It includes error handling to check for invalid input (negative numbers) and returns 1 for input 0. The function is designed to be a clear and concise example of recursive factorial calculation.","checksum":"39ac5682e8649c7e63736061374e73a8b34fd07e3bb0d3417fcab46f28281f82"},"prompts/prompt_context_index_ui.txt":{"token_count":56,"summary":"This file contains a VQQ (Virtual Queue Query Query) message structure. It includes a context, a message, and a Lucas index, likely used for indexing or referencing data within a larger system. The Lucas index is associated with a specific size (vqq_lucas_index_size) and is stored in a Lucas index data structure.","checksum":"aae3584ba3e7ad5450ca8086edfee39364a55d4365db2c066d7dd3db344f648c"},".github/workflows/vimqq-mocks-unittests.yml":{"token_count":146,"summary":"This GitHub Actions workflow runs unit tests for mock servers within a repository. It checks out the code, sets up a Python environment, installs the necessary dependencies from `requirements.txt`, and then executes pytest to run tests located in the `tests/mocks` directory on an Ubuntu runner. The workflow is triggered on pushes and pull requests to the `main` branch.","checksum":"0606649edd4e2a45767971324f1f698ea1d2efeed93e9ae0e417f9bceac4302d"},"tests/local/test_util.vim":{"token_count":1392,"summary":"This file contains a collection of unit tests for the `vimqq#util` module within the `themis` testing suite. The tests cover various string manipulation functions, including string replacement with and without magic characters, newline handling, merging dictionaries, determining the project root, and matching file paths against patterns.  Specifically, the tests validate the behavior of `replace`, `merge`, `root`, `path_matches_patterns`, and `path_matches_patterns_dir` functions, ensuring they correctly handle unicode characters, empty dictionaries, and wildcard/negated path patterns. The tests also verify that the project root is correctly determined to be the current working directory.","checksum":"1163f82d8e32bdf58ee81336501980579f5461787c5867cc3d300233360b06f9"},"autoload/vimqq/msg_builder.vim":{"token_count":1356,"summary":"This Vim plugin provides a `vimqq#msg_builder` object for constructing messages to be sent to the VimQQ service. The builder allows specifying callbacks for various events (e.g., `on_sys_msg`, `on_chunk`, `on_complete`, `on_thinking`) and provides functions to create different types of messages, including user messages (`vimqq#msg_builder#user`), local messages (`vimqq#msg_builder#local`), and tool messages (`vimqq#msg_builder#tool`).  Messages are structured with a `msg` dictionary containing `role`, `bot_name`, `timestamp`, `sources` (for user messages), and a list of `content` elements, each representing a message component (text, tool use, tool result, etc.).  The `set_role`, `set_bot_name`, `set_src_text`, `set_src_context`, `set_src_index`, `tool_result`, and `set_local` functions are used to populate the message structure. The code includes assertions to ensure that input parameters are of the correct type.  The `user` function handles sources for user-initiated messages, which are dynamically created and include question text, context, and potentially index information.","checksum":"dbc9f6b450629ae475b4b6a1e0f8edede9bacc41bdc05f6ba75c18ce147fd053"},"autoload/vimqq/bots/readme.txt":{"token_count":36,"summary":"This document proposes a shift from using separate bots to a system where client instances with tailored implementations handle various tasks. The existing bots will be rebranded as “agents,” specifically categorized as “chat,” “reviewer,” and “indexer.”","checksum":"6d9f6b3134e28817c0de9e003d46f50e273c6d9abf163e86428d32e04e9e4f70"},"autoload/vimqq/msg_render.vim":{"token_count":1154,"summary":"This VimQQ plugin renders messages from the chat interface into a structured format suitable for display. It handles different message roles (local, user, and assistant) and message content types (text, tool results, tool use, thinking, and redacted thinking). Tool results exceeding a length limit of 400 bytes are folded to prevent overly long lines in the chat. The plugin utilizes functions to render specific message types and includes error handling for invalid message roles. It aims to provide a consistent and readable chat experience by formatting tool output and handling various message components.","checksum":"a20418d0ab1a6de4c5a36ac89c620aa3e882838cecaabbcd329381082e266221"},"prompts/indexing_file.txt":{"token_count":39,"summary":"This file provides instructions on how to summarize a given source file for documentation purposes. It requests a concise summary of the file's content to be used as high-level documentation.\n","checksum":"a7b448b8b23424906c2adecc00e5041d619f5fb7a36f387cf45d995eaf8a64b8"},"autoload/vimqq/tools/toolset.vim":{"token_count":1083,"summary":"This Vim script defines a `vimqq#tools#toolset` module that provides a framework for managing and executing various tools within a Vim plugin.  It includes functions for finding the root directory of a Lucas project, creating a toolset with different tools (file retrieval, editing, file creation, and command execution), and handling asynchronous tool calls. The `find_lucas_root` function recursively searches for a `lucas.idx` file to determine the project's root.  The `vimqq#tools#toolset#new` function constructs the toolset, defining functions for accessing tool schemas, running tools asynchronously, and processing messages containing tool usage requests.  The `vimqq#tools#toolset#format` function formats tool calls based on their name.  The module employs asynchronous execution and callback mechanisms to manage tool dependencies and avoid race conditions when accessing shared resources. It also logs debugging information and handles errors gracefully.","checksum":"2cab682abc7c1fa86aeb6d389a933ca0ba4cca708e927ca1d33dd15d71df0919"},"autoload/vimqq/api/anthropic_adapter.vim":{"token_count":551,"summary":"This file defines an adapter for translating tool definitions to a format compatible with the Anthropic API. It includes functions to:\n\n*   `tool_schema()`: Converts a tool schema (containing function name, description, and parameters) into a dictionary suitable for Anthropic.\n*   `adapt_tools()`: Iterates through a list of tools and converts each tool schema into the Anthropic format.\n*   `run()`: Prepares a request for the Anthropic API, including messages, model, token limits, streaming options, and adapted tool definitions.  It also handles system messages and optional \"thinking\" tokens for extended context.","checksum":"78e8793828f468a359e7e1ee9d699e62169273eed6483840c4ebc7e42b1ea142"},"autoload/vimqq/fzf.vim":{"token_count":692,"summary":"This file implements a FuzzyFinder (FZF) integration for the VimQQ plugin, providing a user-friendly interface for browsing and selecting chat messages. It includes functions for formatting chat messages, parsing selected chat IDs, displaying a formatted list of chats in FZF, and handling FZF installation checks.  The core functionality centers around presenting chat history in a searchable and selectable format using FZF, with features like previewing messages and multi-selection.","checksum":"802e9d0a58c6314900520810a22d5bba3dc69d64c609b25970c4712a85a8b08a"},"prompts/reviewer_prompt.txt":{"token_count":157,"summary":"The autonomous agent attempted to resolve a software engineering task by reviewing a conversation transcript and agent actions, including tool calls and file edits. The agent's process involved analyzing the provided context to understand the problem and then executing actions to address it.  The summary highlights the agent’s ability to access and process the entire conversation history, which is a strength, but the overall effectiveness of the solution isn’t explicitly determined within the provided context.  Potential follow-up tasks would depend on whether the task was successfully resolved – if so, further investigation of the agent's reasoning and potential edge cases would be beneficial. If unsuccessful, debugging would require examining the specific tool calls, file edits, and shell commands executed by the agent to identify the source of the error and understand why the intended solution wasn’t achieved.","checksum":"392a4cc5a73778dac46c23c39dc563d96c17edd1364729909bc92aa808d8ffbb"},"tests/.themisrc":{"token_count":183,"summary":"This file configures VIMQQ for testing purposes. It sets logging level to DEBUG, specifies a mock Llama.cpp server at `http://localhost:8888`, an indexer server at the same address, and a custom time format.  A temporary directory for test data and logs (`~/.vim/vimqq_tests`) is created, and the log file and chat database directory are located within that temporary directory.","checksum":"a5675ead92910bf9ebd4fa1282165bf5e01e4b753f0ff78c70f87f52426c6212"},"tests/local/test_controller.vim":{"token_count":1210,"summary":"This Vim file contains a suite of tests for the `vimqq` plugin, specifically focusing on end-to-end (E2E) testing of message sending and chat management. The tests utilize the `Themis` testing framework and `vimqq` helper functions.\n\n**Test Cases:**\n\n1.  **`test_send_message`**: This test sends a message and verifies the resulting chat JSON file. It checks for the correct number of messages (2 - user and assistant), validates the properties of each message (role, bot name, content type, and text), and ensures the chat ID and title are as expected.\n\n2.  **`test_force_new_chat`**: This test simulates creating a new chat using `vimqq#main#send_message` with and without the `force_new_chat` flag. It verifies that chat IDs are assigned correctly (1 for the initial message, 2 for the forced new chat), and that subsequent messages are routed to the appropriate chat. It also checks that the correct number of messages are present in each chat file and that the file names are updated accordingly.\n\n**Setup:**\n\n*   The `before_each` function resets the environment before each test by deleting the chats directory and creating a new buffer.\n*   The tests rely on `g:vqq_chats_dir` to define the directory where chat JSON files are stored.\n*   The tests use `themis#suite` and `themis#helper` for test setup and assertion functions.\n*   The tests utilize `vimqq#main#send_message` for sending messages and `vimqq#log#info` for logging information.\n*   The tests employ `json_decode` and `readfile` for parsing JSON chat files.\n*   `sleep` commands introduce delays to allow the `vimqq` plugin to process messages.\n*   `filter` and `copy` functions are used to manipulate the chat messages.\n*   `glob` function is used to find chat files.\n","checksum":"f855e8cb323a8314b784dcd80657cd1e9fe2395d5a717de02a4146f4f8ef6439"},"autoload/vimqq/indexing.vim":{"token_count":522,"summary":"This file defines the `vimqq#indexing` module, which provides functions for indexing files within a project using Git. It includes functions to create and manage an indexer instance, retrieve project root and index file paths, read and write the index file, get a list of files using `git ls-files`, and process file content tokens for creating a JSON index.  It also includes functions for handling callbacks during indexing operations.","checksum":"a34b9aa7fc69965210e6713105e985c81ed1828bb31d5c7d336748ed8bdcaa7c"},"autoload/vimqq/bots/bots.vim":{"token_count":1298,"summary":"This Vim plugin manages multiple bots, primarily using Llama.cpp and Claude models. It loads bot configurations from global variables (`g:vqq_llama_cpp_servers`, `g:vqq_claude_models`, etc.) and validates bot names.  Key functions include:\n\n*   `s:validate_name()`:  Checks if a bot name is unique, follows naming conventions (letters, numbers, underscores), and doesn't conflict with the reserved `mqq` mock bot.\n*   `s:create()`: Creates a list of bot instances based on configuration lists, utilizing bot factories.\n*   `vimqq#bots#bots#new()`:  The main function to create a bot manager. It initializes a list of bot configurations, creates bot instances using factories, selects a default bot, and adds a mock bot named `mqq`.  It includes functions for retrieving bots by name and selecting a bot based on a question, prioritizing existing conversation tags and then the last used bot.  Error handling is implemented for missing bot names.","checksum":"e3b7e34e823ea394b1519f8d0c29d2303060982c3a625054d2283553a824be83"},"autoload/vimqq/warmup.vim":{"token_count":981,"summary":"This Vim plugin, `vimqq#warmup`, implements a command-line warmup mechanism for the Vimqq plugin. It monitors the command line for specific commands (`QQ` and `QQN`) and sends warmup requests to the backend when they are detected. The warmup process is divided into two categories: one triggered when typing a command and another triggered when opening an old chat or generating a title.  The plugin uses a timer to periodically check the command line for these commands, ensuring that warmups are sent promptly. It also includes logging and error handling to provide debugging information and prevent redundant warmups. The plugin utilizes functions `s:ranged_warmup` for handling warmup requests based on the context, `vimqq#warmup#parse` for parsing command-line input, and `s:check_command_line` for monitoring the command line and triggering warmups.  It's configured using `augroup` to start and stop the timer automatically based on entering and leaving command-line mode.","checksum":"653683980a111f95a36362fbb3f3e5b1dbe4d0856cfe4df70ec571d4d4581ecf"},"tests/local/test_dir/a.txt":{"token_count":0,"summary":"This Python script defines a class `SimpleCalculator` that performs basic arithmetic operations: addition, subtraction, multiplication, and division. It takes two numbers as input and returns the result of the specified operation.  Error handling is included to prevent division by zero, raising a `ZeroDivisionError` in that case.  The script also includes a main execution block that demonstrates the usage of the `SimpleCalculator` class with example calculations and prints the results to the console.\n","checksum":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},"tests/readme.txt":{"token_count":238,"summary":"This file provides instructions on how to use the `themis` command for testing Vimscript code, specifically focusing on tests for string manipulation and formatting. It details how to run all local tests, individual test files (following the `test_*.vim` pattern), and a separate suite of tests that verifies the mock server's compatibility with the official Python Anthropic client. The local tests do not require external API calls and rely on a Python/Flask mock server.","checksum":"e918d6546ff6baee437f2a807ce8768cd89e82aee99775b23abf0af3b112094c"},"autoload/vimqq/bots/llama_cpp_reviewer.vim":{"token_count":438,"summary":"This Vim plugin module, `vimqq#bots#llama_cpp_reviewer#new`, creates a new Llama.cpp-based reviewer bot for use with VimQQ. It initializes a configuration using default settings and extends them with user-provided options. It sets up the bot's API endpoint based on the configured address and creates a base bot client. The `_format` function formats messages for the Llama.cpp API, incorporating a system prompt and user messages, and includes debugging logging. It returns the initialized bot client.","checksum":"8393695cda41f987a7411deba2c25be5340c6ee5b90ef130016aca05fc8c512e"},"autoload/vimqq/api/anthropic_builder.vim":{"token_count":1352,"summary":"This Vim plugin provides an API for constructing messages to the Anthropic Claude assistant. The `vimqq#api#anthropic_builder#streaming` function creates a message builder object, which allows for the incremental construction of a message by adding content blocks (text, JSON, or thinking) using functions like `content_block_start`, `content_block_delta`, and `content_block_stop`.  These functions perform validation checks to ensure the message is built correctly, handling different types of content updates.  The `vimqq#api#anthropic_builder#plain` function offers a simpler approach for creating messages by collecting parts as a list of strings and then converting them to a JSON object before sending. Both functions utilize internal message building and event handling mechanisms within the `vimqq` plugin architecture.","checksum":"32caad5db3882dd8fae3ff33bc1f4ff0b37ac2ce218c8a36056fd64920fa5f0e"}}
